# Blackjack
This was a personal project of mine in order to create a pre-existing game within Java. I chose Blackjack since it had a fairly simple rule set and very few check conditions in order to determine the conditions. This project contains 2 files, **Blackjack.java** which is the main class that does all the work and contains the main method, and **Card.java** which creates Card Objects for Blackjack.java to use. 

This is my work outside the discipline, as well as the work with outside application, that being it is able to enjoyed by non-computer science individuals as a bit of time-wasting fun.

## How to Play
The aim of the game is to get your score in each round to be as close to 21 as possible without going over. Each card has a particular value associated with it that adds to ones score:

**Number Cards** (2-10) are worth their face value.
**Face Cards** (Jacks, Queens, and Kings) are worth 10 points.
**Aces** are either worth 11 points or 1 point, which most benefits the player.

The suit is irrelevant. 

When it's their turn, a player can do one of 2 things:
**Hit**, and pull the next card off the deck, or 
**Stand**, and move to the next player.

This variation of Blackjack only consists of 2 people, the human player and a CPU dealer. 
At the beginning of a round, both players are dealt a single card, then the human player starts their turn. They play until they either go over 21 or stand. It then moves on to the dealer who will try to top the player. 

**The player wins if:**

- The dealer exceeds 21 points.

**The dealer wins if:**

- The player exceeds 21 points.
- The dealer beats the player's score without going over 21.

**The game is a draw if:**

- The player and dealer are tied and the dealer stands.
- The player and dealer both get exactly 21 points.

# Mechanics
Blackjack.java begins by declaring some variables. One of these is the deck itself, which is a Card Object Array of size 52 generated by a method called **generateDeck()**;
## Deck Generation
The generateDeck() method generates the cards using two nested for loops: an outer one of "j" that gives 13 values from 0 to 12, and an inner loop  of "k" that gives 4 values from 0 to 3. 

For each loop, a switch case runs through the current inner loop value to determine the suit. While not relevant for scoring, the suit is included to help the player distinguish cards.

A second switch case then runs through the current outer loop value to get the face values. The values are not generated in  traditional card order; when the index is 0, the face is made a King. This helps for better alignment for other cards without an awkward offset; index 1 can now be for the Ace, and indices 2-10 go to their corresponding number cards, leaving indices 11 and 12 for the Jack and Queen respectively. 

Once the suit and face is determined for each nested loop, a constructor method is called to generate each card object. There are two constructors in Card.java. 

**The primary constructor**, which sets the face and suit values, as well as 2 integers, a primary and secondary value. And...
**The secondary constructor** which also sets the face and suit, but only has 1 integer slot. 

As Aces are the only cards with 2 different values, only they call the primary constructor direct. All the other cards call the secondary constructor, which in turn calls the primary constructor with both ints being the same. Finally, the cards are sorted into the deck using the formula k*13+j and a deck is generated.
## Shuffling the Deck
At the start of each round, the deck is shuffled using the **shuffleDeck()** method. This simply converts the deck array into a List<>, uses the shuffle function, and then converts it back into a array. 
## Starting the game
The game begins within the while loop that continues as long as the player wishes to play. At the start of the game, all scores are set to  0, or other values are set to their neutral state, and the deck is shuffled. Then with the help of an incrementing pointer, 2 cards are dealt, one for the dealer and then one for the player.  Their values are added their respective players' score. At which point the player's turn begins.
## Player's turn
A while loop for the player's turn begins. As a player plays cards, a score counter is shown (along with the dealers score) to give information to the player. Points are added from the cards. If the player has less than 11 points, the primary value is added, otherwise the secondary. This was the simplest way to implement the ace. As the loop loops, it checks for one of 3 states:

1. **The player's score exceeds 21**
In that case, the player's turn ends and the dealer is declared the winner and the player's turn automatically ends. A check immediately after the player's turn while loop prevents the game from moving to the dealer's turn. 
2. **The player's score is less than 21**
In that case, the game is still on, and the player can use their judgement on whether it is best to Hit or Stand. If the player hits, the process is repeated. If they stand, they end their turn. This is determined with Scanner object user input following a **[H]it/[S]tand** prompt. I was unable to implement key listening properly, so this was the next best thing. As it is set up now, if the player inputs either "S" or "s", then the game stands, otherwise it hits.
3. **The player's score is exactly 21**
Blackjack! The game automatically stands for the player and it ends their turn.

## Dealer's Turn
Another while loop is entered, this time for the dealer. The dealer follows similar motions to the player, with points being added the same way as the human player. However, this is done automatically and with the goal of beating the player's score.  As the loop loops, it's looking for one of five states:

1. **The dealer's score exceeds 21**
The player is declared the winner and the dealer's turn ends.
2. **The dealer's score beats the player's without going over 21**
The dealer is declared the winner and their turn ends.
3. **Both players' scores are exactly 21**
The game is declared a draw and their turn ends.
4. **The dealer's score is less than the player's or tied below 12**
The dealer will always decides to hit, therefore drawing another card and doing another loop.
5. **The dealer is tied with the player between 12 and 20**
In this case the dealer will decide whether or not to risk pulling another card. This is done by generating a random number using Random() and seeing if it's above a certain threshold depending on the score. If the threshold is met or exceeded, the dealer hits and another loop is ran. Otherwise, the dealer stands, resulting in a draw and ending their turn. The higher the score in this case, the more likely the dealer will stand. The probabilities are as followed:
**12:** 10%	**15:** 40%	**18:** 70%
**13:** 20%	**16:** 50%	**19:** 80%
**14:** 30%	**17:** 60%	**20:** 90%

Also, for every one of these possibilities, Thread.sleep() is used to wait a few seconds in-between moves. This is for various reasons. For cases 1-3, a 1 second delay helps the player process what has occurred. The same for cases 4 and 5 if the dealer hits, however the timing is different and has a different reason. It starts at 2 seconds and adds an additional half second for every point above 11. This simulates someone thinking as well as make the game more suspenseful.
## Declaring the winner.
After the dealers round (or past it if the player goes over 21), a switch case checks who the winner is and congratulates them (or if there is a draw, declare said draw).
## Asking for replay
After the round, regardless of outcome, a prompt asks the player wishes for another round. If they say yes, then all steps above except declaring variables are done over, resetting the game. If they say no, then the while(playing) loop exits, terminating the application. This is also done with the Scanner object with a **[Y]es/[N]o** prompt. If the player enters "N" or "n", the game terminates, otherwise it begins a new round.